## LLR RAM

### 端口安排

基矩阵的每一个元素对应一块双端口 RAM，所谓的双端口，即一个读端口，一个写端口，仅此而已，针对我们不同输入的需求，我们需要一些 MUX。

在我们的设计中，会产生三种状态下的写入：initial_on（初始化 llr），cpu_on（CPU 更新） 和 vpu_on（VPU 更新）；以及两种状态下的读出：cpu_on 和 vpu_on。在 initial_on 状态下，不需要从 llr_ram 读出 llr。

以上的设计与第一版的译码器完全相同。

端口安排好了，接下来的问题是读写地址的生成。

### 地址生成器

主要是读写地址的生成，还是和之前的设计保持一致，先不考虑 initial_on 有效时的读写地址生成。

cpu_on 有效时，从 0 到 255 依次产生读地址，这个宽度比较合适，不用判断相等以归 0；写地址是读地址延迟 M 个时钟的结果。

vpu_on 有效时，每个读地址生成器与基矩阵元素相关，因此需要提前生成一些参数供初始化使用；写地址是读地址延迟 N 个时钟的结果。

以上方案与第一版保持一致，但还是存在一个我之前一直担心的问题：**从读地址到写地址的延迟 M 和 N 如果过大的话，需要大量的资源用于延迟，如果消耗过大，还不如直接多配置一套写地址生成器。**

initial_on 时写地址与 vpu_on 时的读地址完全相同。

以上的地址生成器方案和第一版的设计保持一致。

---

这样一来，大概说明白了我们的译码器 ram 该怎么样去安排，结合上 controller 就是另外一个难度的事情了。